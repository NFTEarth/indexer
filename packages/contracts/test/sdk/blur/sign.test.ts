import { defaultAbiCoder } from "@ethersproject/abi";
import { keccak256 } from "@ethersproject/solidity";
import { verifyTypedData } from "@ethersproject/wallet";
import * as Blur from "@reservoir0x/sdk/src/blur";
import { SignerWithAddress } from "@nomiclabs/hardhat-ethers/dist/src/signer-with-address";
import { expect } from "chai";
import { ethers } from "hardhat";
import { MerkleTree } from "merkletreejs";

import { getChainId, reset } from "../../utils";

describe("Blur - signature check", () => {
  const chainId = getChainId();

  let deployer: SignerWithAddress;
  let alice: SignerWithAddress;
  let bob: SignerWithAddress;
  let carol: SignerWithAddress;
  let ted: SignerWithAddress;

  beforeEach(async () => {
    [deployer, alice, bob, carol, ted] = await ethers.getSigners();
  });

  afterEach(reset);

  it("sign", async () => {
    const exchange = new Blur.Exchange(chainId);
    const builder = new Blur.Builders.SingleToken(chainId);

    const inputData = exchange.contract.interface.decodeFunctionData(
      "execute",
      `0x9a1fc3a70000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000036000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000001b602a8015af4f4f897adde7cc5ec0701f422789b4828ac0f1899ee245764c3884739c1b50aaddb4b4f2a1c602976997d99e9968f39dff0ec282eea5b753534a2c000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f23eb100000000000000000000000029e44b41e191531b07d6b5cb9e03c3bece1373aa000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000006411739da1c40b106f8511de5d1fac0000000000000000000000003fe1a4c1481c8351e91b64d5c398b159de07cbc50000000000000000000000000000000000000000000000000000000000000c820000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003311fc80a57000000000000000000000000000000000000000000000000000000000000635e83ff000000000000000000000000000000000000000000000000000000006367be7e00000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000002b909f741233a66b1750c4e867ae7675000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000064000000000000000000000000aae014af95d811ad7dbff60209e74551a338f64c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002c000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f23eb10000000000000000000000002128f6d85dfdd6cf1b92eebf38eab41716e5becd000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006411739da1c40b106f8511de5d1fac0000000000000000000000003fe1a4c1481c8351e91b64d5c398b159de07cbc50000000000000000000000000000000000000000000000000000000000000c820000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003311fc80a5700000000000000000000000000000000000000000000000000000000000063611e6a0000000000000000000000000000000000000000000000000000000063613a8a00000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000009a0ed79db7e1083b50890a647607f64900000000000000000000000000000000000000000000000000000000000001c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000`
    );
    // console.log('inputData.buy', inputData.buy)
    // console.log('inputData.sell', inputData.sell)
    const sellOrder1 = inputData.sell[0];
    // const curTimestamp = (await getCurrentTimestamp(ethers.provider));
    // console.log("curTimestamp", curTimestamp)

    function getOrder(sellOrder: any) {
      console.log("sellOrder", sellOrder);
      return {
        side: sellOrder.side === 1 ? "sell" : "buy",
        trader: sellOrder.trader,
        collection: sellOrder.collection,
        tokenId: sellOrder.tokenId.toString(),
        amount: sellOrder.amount.toString(),
        paymentToken: sellOrder.paymentToken,
        price: sellOrder.price.toString(),
        listingTime: sellOrder.listingTime.toString(),
        matchingPolicy: sellOrder.matchingPolicy,
        nonce: 0,
        expirationTime: sellOrder.expirationTime.toString(),
        fees: sellOrder.fees.map((_: any) => {
          return {
            rate: _.rate,
            recipient: _.recipient,
          };
        }),
        salt: sellOrder.salt.toString(),
        extraParams: sellOrder.extraParams,
      };
    }

    // console.log('sellOrder', getOrder(sellOrder1))
    // console.log('buyOrder', getOrder(inputData.buy[0]))
    const buyOrder = builder.build({
      side: "sell",
      trader: sellOrder1.trader,
      collection: sellOrder1.collection,
      tokenId: sellOrder1.tokenId.toString(),
      amount: sellOrder1.amount.toString(),
      paymentToken: sellOrder1.paymentToken,
      price: sellOrder1.price.toString(),
      listingTime: sellOrder1.listingTime.toString(),
      matchingPolicy: sellOrder1.matchingPolicy,
      nonce: 0,
      expirationTime: sellOrder1.expirationTime.toString(),
      fees: sellOrder1.fees.map((_: any) => {
        return {
          rate: _.rate,
          recipient: _.recipient,
        };
      }),
      salt: sellOrder1.salt.toString(),
      extraParams: sellOrder1.extraParams,
    });

    const tx = await ethers.provider.getTransactionReceipt(
      "0xc02aa94cd1b594d93afd2e5ea7890402f3b38329abdb5f188bf449ebb4dbd12a"
    );
    const orderHash = buyOrder.hash();
    const eventData = exchange.contract.interface.decodeEventLog(
      "OrdersMatched",
      tx.logs[3].data
    );
    // console.log("OrdersMatched",eventData.sellHash)

    expect(orderHash).to.be.eq(eventData.sellHash);
  });

  it("bulkSign", async () => {
    const rawData = `0x9a1fc3a70000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000038000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000001bacee62d7acadd0ae2b3a3a5a674f97671659ce51c9c292ac4a4c2193b3a0891042c94a13168ff144eb30131161d8b0aabb588296d5db1713ce58fd480d3bf09700000000000000000000000000000000000000000000000000000000000002c000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000f26fdf000000000000000000000000f65d928d8c143e49096cf666095a2be54bd431eb000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000006411739da1c40b106f8511de5d1fac00000000000000000000000005da517b1bf9999b7762eaefa8372341a1a475590000000000000000000000000000000000000000000000000000000000001668000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000917070797e18000000000000000000000000000000000000000000000000000000000006362a59800000000000000000000000000000000000000000000000000000000638a329800000000000000000000000000000000000000000000000000000000000001a000000000000000000000000000000000053cae46abac64a5d1dc3a8ad0746b5c00000000000000000000000000000000000000000000000000000000000001c000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000001d89573ca21c1878c2b55da13ef170bbcd599defb26a6e277239b686e38bb1e1900000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002c000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f26fdf00000000000000000000000000fb2499403afeccd48f0fb29da41cde8c113d4b000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006411739da1c40b106f8511de5d1fac00000000000000000000000005da517b1bf9999b7762eaefa8372341a1a475590000000000000000000000000000000000000000000000000000000000001668000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000917070797e180000000000000000000000000000000000000000000000000000000000063636fa90000000000000000000000000000000000000000000000000000000063638bc900000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000002d01851a2889aa9cb3ccd62f4322510e00000000000000000000000000000000000000000000000000000000000001c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000`;
    const exchange = new Blur.Exchange(chainId);
    const builder = new Blur.Builders.SingleToken(chainId);
    const inputData = exchange.contract.interface.decodeFunctionData(
      "execute",
      rawData
    );

    function getOrder(sellInput: any) {
      const sellOrder = sellInput.order;
      return {
        side: sellOrder.side === 1 ? "sell" : "buy",
        trader: sellOrder.trader,
        collection: sellOrder.collection,
        tokenId: sellOrder.tokenId.toString(),
        amount: sellOrder.amount.toString(),
        paymentToken: sellOrder.paymentToken,
        price: sellOrder.price.toString(),
        listingTime: sellOrder.listingTime.toString(),
        matchingPolicy: sellOrder.matchingPolicy,
        nonce: 0,
        expirationTime: sellOrder.expirationTime.toString(),
        fees: sellOrder.fees.map((_: any) => {
          return {
            rate: _.rate,
            recipient: _.recipient,
          };
        }),
        salt: sellOrder.salt.toString(),
        extraParams: sellOrder.extraParams,
        r: sellInput.r,
        v: sellInput.v,
        s: sellInput.s,
        extraSignature: sellInput.extraSignature,
        signatureVersion: sellInput.signatureVersion,
      };
    }

    const sellOrderRaw = getOrder(inputData.sell);
    const sellOrder = builder.build(sellOrderRaw as any);

    const sellOrderHash = sellOrder.hash();
    const sellInput = inputData.sell;
    const merklePath = defaultAbiCoder.decode(
      ["bytes32[]"],
      sellInput.extraSignature
    )[0];
    const tree = new MerkleTree([], keccak256, {
      sort: true,
    });

    function computedRoot(
      tree: MerkleTree,
      proof: string[],
      targetNode: string
    ) {
      const hashFn = tree.bufferifyFn(keccak256);
      let hash = tree.bufferify(targetNode);
      for (let i = 0; i < proof.length; i++) {
        const node = proof[i];
        let data = null;
        let isLeftNode = null;
        if (typeof node === "string") {
          data = tree.bufferify(node);
          isLeftNode = true;
        } else {
          throw new Error("Expected node to be of type string or object");
        }
        const buffers = [];
        if (Buffer.compare(hash, data) === -1) {
          buffers.push(hash, data);
          hash = hashFn(Buffer.concat(buffers));
        } else {
          buffers.push(data, hash);
          hash = hashFn(Buffer.concat(buffers));
        }
      }
      return tree.bufferToHex(hash);
    }

    tree.addLeaf(MerkleTree.bufferify(sellOrderHash));
    const root1 = computedRoot(tree, merklePath, sellOrderHash);
    tree.verify(merklePath, sellOrderHash, "0x");
    const signature = {
      v: sellInput.v,
      r: sellInput.r ?? "",
      s: sellInput.s ?? "",
    };
    const root =
      "0xac3bb6c94918514a01d086204abee9920c76dad439ea19d5ca0b702c8fcce368";

    const signer = verifyTypedData(
      {
        name: "Blur Exchange",
        version: "1.0",
        chainId: 1,
        verifyingContract: "0x000000000000ad05ccc4f10045630fb830b95127",
      },
      {
        Root: [{ name: "root", type: "bytes32" }],
      },
      {
        root,
      },
      signature
    );

    const tx = await ethers.provider.getTransactionReceipt(
      "0x7cf6dffef7b3ecc095835264512bf3a16aab9589abb337e5500f9617509739d3"
    );
    const eventData = exchange.contract.interface.decodeEventLog(
      "OrdersMatched",
      tx.logs[1].data
    );

    expect(eventData.sellHash).to.eq(sellOrderHash);
    sellOrder.checkSignature();
  });
});
